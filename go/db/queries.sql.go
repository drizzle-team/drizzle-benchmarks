// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const customerById = `-- name: CustomerById :one
select "d0"."id" as "id", "d0"."company_name" as "companyName", "d0"."contact_name" as "contactName", "d0"."contact_title" as "contactTitle", "d0"."address" as "address", "d0"."city" as "city", "d0"."postal_code" as "postalCode", "d0"."region" as "region", "d0"."country" as "country", "d0"."phone" as "phone", "d0"."fax" as "fax" from "customers" as "d0" where "d0"."id" = $1
`

func (q *Queries) CustomerById(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRow(ctx, customerById, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.ContactName,
		&i.ContactTitle,
		&i.Address,
		&i.City,
		&i.PostalCode,
		&i.Region,
		&i.Country,
		&i.Phone,
		&i.Fax,
	)
	return i, err
}

const customers = `-- name: Customers :many
select "d0"."id" as "id", "d0"."company_name" as "companyName", "d0"."contact_name" as "contactName", "d0"."contact_title" as "contactTitle", "d0"."address" as "address", "d0"."city" as "city", "d0"."postal_code" as "postalCode", "d0"."region" as "region", "d0"."country" as "country", "d0"."phone" as "phone", "d0"."fax" as "fax" from "customers" as "d0" order by "d0"."id" asc limit $1 offset $2
`

type CustomersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) Customers(ctx context.Context, arg CustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, customers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.PostalCode,
			&i.Region,
			&i.Country,
			&i.Phone,
			&i.Fax,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const employeeWithRecipient = `-- name: EmployeeWithRecipient :one
select "d0"."id" as "id", "d0"."last_name" as "lastName", "d0"."first_name" as "firstName", "d0"."title" as "title", "d0"."title_of_courtesy" as "titleOfCourtesy", "d0"."birth_date" as "birthDate", "d0"."hire_date" as "hireDate", "d0"."address" as "address", "d0"."city" as "city", "d0"."postal_code" as "postalCode", "d0"."country" as "country", "d0"."home_phone" as "homePhone", "d0"."extension" as "extension", "d0"."notes" as "notes", "d0"."recipient_id" as "recipientId", "recipient"."r" as "recipient" from "employees" as "d0" left join lateral(select row_to_json("t".*) "r" from (select "d1"."id" as "id", "d1"."last_name" as "lastName", "d1"."first_name" as "firstName", "d1"."title" as "title", "d1"."title_of_courtesy" as "titleOfCourtesy", "d1"."birth_date" as "birthDate", "d1"."hire_date" as "hireDate", "d1"."address" as "address", "d1"."city" as "city", "d1"."postal_code" as "postalCode", "d1"."country" as "country", "d1"."home_phone" as "homePhone", "d1"."extension" as "extension", "d1"."notes" as "notes", "d1"."recipient_id" as "recipientId" from "employees" as "d1" where "d0"."recipient_id" = "d1"."id") as "t") as "recipient" on true where "d0"."id" = $1
`

type EmployeeWithRecipientRow struct {
	ID              int32
	LastName        string
	FirstName       pgtype.Text
	Title           string
	TitleOfCourtesy string
	BirthDate       pgtype.Date
	HireDate        pgtype.Date
	Address         string
	City            string
	PostalCode      string
	Country         string
	HomePhone       string
	Extension       int32
	Notes           string
	RecipientId     pgtype.Int4
	Recipient       []byte
}

func (q *Queries) EmployeeWithRecipient(ctx context.Context, id int32) (EmployeeWithRecipientRow, error) {
	row := q.db.QueryRow(ctx, employeeWithRecipient, id)
	var i EmployeeWithRecipientRow
	err := row.Scan(
		&i.ID,
		&i.LastName,
		&i.FirstName,
		&i.Title,
		&i.TitleOfCourtesy,
		&i.BirthDate,
		&i.HireDate,
		&i.Address,
		&i.City,
		&i.PostalCode,
		&i.Country,
		&i.HomePhone,
		&i.Extension,
		&i.Notes,
		&i.RecipientId,
		&i.Recipient,
	)
	return i, err
}

const employees = `-- name: Employees :many
select "d0"."id" as "id", "d0"."last_name" as "lastName", "d0"."first_name" as "firstName", "d0"."title" as "title", "d0"."title_of_courtesy" as "titleOfCourtesy", "d0"."birth_date" as "birthDate", "d0"."hire_date" as "hireDate", "d0"."address" as "address", "d0"."city" as "city", "d0"."postal_code" as "postalCode", "d0"."country" as "country", "d0"."home_phone" as "homePhone", "d0"."extension" as "extension", "d0"."notes" as "notes", "d0"."recipient_id" as "recipientId" from "employees" as "d0" order by "d0"."id" asc limit $1 offset $2
`

type EmployeesParams struct {
	Limit  int32
	Offset int32
}

type EmployeesRow struct {
	ID              int32
	LastName        string
	FirstName       pgtype.Text
	Title           string
	TitleOfCourtesy string
	BirthDate       pgtype.Date
	HireDate        pgtype.Date
	Address         string
	City            string
	PostalCode      string
	Country         string
	HomePhone       string
	Extension       int32
	Notes           string
	RecipientId     pgtype.Int4
}

func (q *Queries) Employees(ctx context.Context, arg EmployeesParams) ([]EmployeesRow, error) {
	rows, err := q.db.Query(ctx, employees, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmployeesRow
	for rows.Next() {
		var i EmployeesRow
		if err := rows.Scan(
			&i.ID,
			&i.LastName,
			&i.FirstName,
			&i.Title,
			&i.TitleOfCourtesy,
			&i.BirthDate,
			&i.HireDate,
			&i.Address,
			&i.City,
			&i.PostalCode,
			&i.Country,
			&i.HomePhone,
			&i.Extension,
			&i.Notes,
			&i.RecipientId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const orderWithDetails = `-- name: OrderWithDetails :one
select "orders"."id", "orders"."shipped_date", "orders"."ship_name", "orders"."ship_city", "orders"."ship_country", count("order_details"."product_id")::int, sum("order_details"."quantity")::int, sum("order_details"."quantity" * "order_details"."unit_price")::real from "orders" left join "order_details" on "order_details"."order_id" = "orders"."id" where "orders"."id" = $1 group by "orders"."id" order by "orders"."id" asc
`

type OrderWithDetailsRow struct {
	ID          int32
	ShippedDate pgtype.Date
	ShipName    string
	ShipCity    string
	ShipCountry string
	Column6     int32
	Column7     int32
	Column8     float32
}

func (q *Queries) OrderWithDetails(ctx context.Context, id int32) (OrderWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, orderWithDetails, id)
	var i OrderWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ShippedDate,
		&i.ShipName,
		&i.ShipCity,
		&i.ShipCountry,
		&i.Column6,
		&i.Column7,
		&i.Column8,
	)
	return i, err
}

const orderWithDetailsAndProducts = `-- name: OrderWithDetailsAndProducts :one
select "d0"."id" as "id", "d0"."order_date" as "orderDate", "d0"."required_date" as "requiredDate", "d0"."shipped_date" as "shippedDate", "d0"."ship_via" as "shipVia", "d0"."freight" as "freight", "d0"."ship_name" as "shipName", "d0"."ship_city" as "shipCity", "d0"."ship_region" as "shipRegion", "d0"."ship_postal_code" as "shipPostalCode", "d0"."ship_country" as "shipCountry", "d0"."customer_id" as "customerId", "d0"."employee_id" as "employeeId", "details"."r" as "details" from "orders" as "d0" left join lateral(select coalesce(json_agg(row_to_json("t".*)), '[]') as "r" from (select "d1"."unit_price" as "unitPrice", "d1"."quantity" as "quantity", "d1"."discount" as "discount", "d1"."order_id" as "orderId", "d1"."product_id" as "productId", "product"."r" as "product" from "order_details" as "d1" left join lateral(select row_to_json("t".*) "r" from (select "d2"."id" as "id", "d2"."name" as "name", "d2"."qt_per_unit" as "quantityPerUnit", "d2"."unit_price" as "unitPrice", "d2"."units_in_stock" as "unitsInStock", "d2"."units_on_order" as "unitsOnOrder", "d2"."reorder_level" as "reorderLevel", "d2"."discontinued" as "discontinued", "d2"."supplier_id" as "supplierId" from "products" as "d2" where "d1"."product_id" = "d2"."id") as "t") as "product" on true where "d0"."id" = "d1"."order_id") as "t") as "details" on true where "d0"."id" = $1
`

type OrderWithDetailsAndProductsRow struct {
	ID             int32
	OrderDate      pgtype.Date
	RequiredDate   pgtype.Date
	ShippedDate    pgtype.Date
	ShipVia        int32
	Freight        float64
	ShipName       string
	ShipCity       string
	ShipRegion     pgtype.Text
	ShipPostalCode pgtype.Text
	ShipCountry    string
	CustomerId     int32
	EmployeeId     int32
	Details        interface{}
}

func (q *Queries) OrderWithDetailsAndProducts(ctx context.Context, id int32) (OrderWithDetailsAndProductsRow, error) {
	row := q.db.QueryRow(ctx, orderWithDetailsAndProducts, id)
	var i OrderWithDetailsAndProductsRow
	err := row.Scan(
		&i.ID,
		&i.OrderDate,
		&i.RequiredDate,
		&i.ShippedDate,
		&i.ShipVia,
		&i.Freight,
		&i.ShipName,
		&i.ShipCity,
		&i.ShipRegion,
		&i.ShipPostalCode,
		&i.ShipCountry,
		&i.CustomerId,
		&i.EmployeeId,
		&i.Details,
	)
	return i, err
}

const ordersWithDetails = `-- name: OrdersWithDetails :many
select "orders"."id", "orders"."shipped_date", "orders"."ship_name", "orders"."ship_city", "orders"."ship_country", count("order_details"."product_id")::int, sum("order_details"."quantity")::int, sum("order_details"."quantity" * "order_details"."unit_price")::real from "orders" left join "order_details" on "order_details"."order_id" = "orders"."id" group by "orders"."id" order by "orders"."id" asc limit $1 offset $2
`

type OrdersWithDetailsParams struct {
	Limit  int32
	Offset int32
}

type OrdersWithDetailsRow struct {
	ID          int32
	ShippedDate pgtype.Date
	ShipName    string
	ShipCity    string
	ShipCountry string
	Column6     int32
	Column7     int32
	Column8     float32
}

func (q *Queries) OrdersWithDetails(ctx context.Context, arg OrdersWithDetailsParams) ([]OrdersWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, ordersWithDetails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersWithDetailsRow
	for rows.Next() {
		var i OrdersWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ShippedDate,
			&i.ShipName,
			&i.ShipCity,
			&i.ShipCountry,
			&i.Column6,
			&i.Column7,
			&i.Column8,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productWithSupplier = `-- name: ProductWithSupplier :one
select "d0"."id" as "id", "d0"."name" as "name", "d0"."qt_per_unit" as "quantityPerUnit", "d0"."unit_price" as "unitPrice", "d0"."units_in_stock" as "unitsInStock", "d0"."units_on_order" as "unitsOnOrder", "d0"."reorder_level" as "reorderLevel", "d0"."discontinued" as "discontinued", "d0"."supplier_id" as "supplierId", "supplier"."r" as "supplier" from "products" as "d0" left join lateral(select row_to_json("t".*) "r" from (select "d1"."id" as "id", "d1"."company_name" as "companyName", "d1"."contact_name" as "contactName", "d1"."contact_title" as "contactTitle", "d1"."address" as "address", "d1"."city" as "city", "d1"."region" as "region", "d1"."postal_code" as "postalCode", "d1"."country" as "country", "d1"."phone" as "phone" from "suppliers" as "d1" where "d0"."supplier_id" = "d1"."id") as "t") as "supplier" on true where "d0"."id" = $1
`

type ProductWithSupplierRow struct {
	ID              int32
	Name            string
	QuantityPerUnit string
	UnitPrice       float64
	UnitsInStock    int32
	UnitsOnOrder    int32
	ReorderLevel    int32
	Discontinued    int32
	SupplierId      int32
	Supplier        []byte
}

func (q *Queries) ProductWithSupplier(ctx context.Context, id int32) (ProductWithSupplierRow, error) {
	row := q.db.QueryRow(ctx, productWithSupplier, id)
	var i ProductWithSupplierRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.QuantityPerUnit,
		&i.UnitPrice,
		&i.UnitsInStock,
		&i.UnitsOnOrder,
		&i.ReorderLevel,
		&i.Discontinued,
		&i.SupplierId,
		&i.Supplier,
	)
	return i, err
}

const products = `-- name: Products :many
select "d0"."id" as "id", "d0"."name" as "name", "d0"."qt_per_unit" as "quantityPerUnit", "d0"."unit_price" as "unitPrice", "d0"."units_in_stock" as "unitsInStock", "d0"."units_on_order" as "unitsOnOrder", "d0"."reorder_level" as "reorderLevel", "d0"."discontinued" as "discontinued", "d0"."supplier_id" as "supplierId" from "products" as "d0" order by "d0"."id" asc limit $1 offset $2
`

type ProductsParams struct {
	Limit  int32
	Offset int32
}

type ProductsRow struct {
	ID              int32
	Name            string
	QuantityPerUnit string
	UnitPrice       float64
	UnitsInStock    int32
	UnitsOnOrder    int32
	ReorderLevel    int32
	Discontinued    int32
	SupplierId      int32
}

func (q *Queries) Products(ctx context.Context, arg ProductsParams) ([]ProductsRow, error) {
	rows, err := q.db.Query(ctx, products, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsRow
	for rows.Next() {
		var i ProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.QuantityPerUnit,
			&i.UnitPrice,
			&i.UnitsInStock,
			&i.UnitsOnOrder,
			&i.ReorderLevel,
			&i.Discontinued,
			&i.SupplierId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomer = `-- name: SearchCustomer :many
select "d0"."id" as "id", "d0"."company_name" as "companyName", "d0"."contact_name" as "contactName", "d0"."contact_title" as "contactTitle", "d0"."address" as "address", "d0"."city" as "city", "d0"."postal_code" as "postalCode", "d0"."region" as "region", "d0"."country" as "country", "d0"."phone" as "phone", "d0"."fax" as "fax" from "customers" as "d0" where to_tsvector('english', "d0"."company_name") @@ to_tsquery('english', $1)
`

func (q *Queries) SearchCustomer(ctx context.Context, toTsquery string) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchCustomer, toTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.PostalCode,
			&i.Region,
			&i.Country,
			&i.Phone,
			&i.Fax,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProduct = `-- name: SearchProduct :many
select "d0"."id" as "id", "d0"."name" as "name", "d0"."qt_per_unit" as "quantityPerUnit", "d0"."unit_price" as "unitPrice", "d0"."units_in_stock" as "unitsInStock", "d0"."units_on_order" as "unitsOnOrder", "d0"."reorder_level" as "reorderLevel", "d0"."discontinued" as "discontinued", "d0"."supplier_id" as "supplierId" from "products" as "d0" where to_tsvector('english', "d0"."name") @@ to_tsquery('english', $1)
`

type SearchProductRow struct {
	ID              int32
	Name            string
	QuantityPerUnit string
	UnitPrice       float64
	UnitsInStock    int32
	UnitsOnOrder    int32
	ReorderLevel    int32
	Discontinued    int32
	SupplierId      int32
}

func (q *Queries) SearchProduct(ctx context.Context, toTsquery string) ([]SearchProductRow, error) {
	rows, err := q.db.Query(ctx, searchProduct, toTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductRow
	for rows.Next() {
		var i SearchProductRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.QuantityPerUnit,
			&i.UnitPrice,
			&i.UnitsInStock,
			&i.UnitsOnOrder,
			&i.ReorderLevel,
			&i.Discontinued,
			&i.SupplierId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const supplierById = `-- name: SupplierById :one
select "d0"."id" as "id", "d0"."company_name" as "companyName", "d0"."contact_name" as "contactName", "d0"."contact_title" as "contactTitle", "d0"."address" as "address", "d0"."city" as "city", "d0"."region" as "region", "d0"."postal_code" as "postalCode", "d0"."country" as "country", "d0"."phone" as "phone" from "suppliers" as "d0" where "d0"."id" = $1
`

func (q *Queries) SupplierById(ctx context.Context, id int32) (Supplier, error) {
	row := q.db.QueryRow(ctx, supplierById, id)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.ContactName,
		&i.ContactTitle,
		&i.Address,
		&i.City,
		&i.Region,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
	)
	return i, err
}

const suppliers = `-- name: Suppliers :many
select "d0"."id" as "id", "d0"."company_name" as "companyName", "d0"."contact_name" as "contactName", "d0"."contact_title" as "contactTitle", "d0"."address" as "address", "d0"."city" as "city", "d0"."region" as "region", "d0"."postal_code" as "postalCode", "d0"."country" as "country", "d0"."phone" as "phone" from "suppliers" as "d0" order by "d0"."id" asc limit $1 offset $2
`

type SuppliersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) Suppliers(ctx context.Context, arg SuppliersParams) ([]Supplier, error) {
	rows, err := q.db.Query(ctx, suppliers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.ContactName,
			&i.ContactTitle,
			&i.Address,
			&i.City,
			&i.Region,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
